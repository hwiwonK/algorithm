## TIP
BFS 할 때, queue에 넣을 때 visit 체크하는 것이 효율적이다(queue에 같은 것 또 들어가지 않게 하기 위해)<br>
정렬할 때 map 자료구조 쓰면 -> 넣거나 뺄 때 nlogn : 효율적임<br>
구조체는 한번에 초기화 가능!<br>
DP는 top-down 말고 반복형태로 해야 최적의 성능 낼 수 있다<br>
문자열 인덱스 1부터 받기 : scanf("%s", a+1) <br>
-1e9 : - 10억<br>

## 문제풀이
### S1249
bfs로 풀어보기
(다익스트라, 다익스트라 + 우선순위큐, dfs)

### J2613 (BFS)
BFS 이용해서 풀이하기<br>
익은 토마토를 queue에 넣어놓고, 상-하-좌-우 체크하며 안 익은 것 queue에 넣고 level 체크
queue의 마지막 원소의 level 반환

0인 토마토 찾기 -> 1까지 최단거리 찾기 (시간 초과)

### J1113
새로운 minCorner 선언 안하고, 기존 input 배열 이용해도 됨

### J1906 (Disjoint Set)
공통 조상을 구하느 방법 <br>
visit 배열 이용하는 방법 -> 이 문제에서는 count 를 저장하면 됨 (촌수 계산 위해) <br>
level 이용하는 방법 -> 메모리 사용 안해도 됨
***부모 정보 저장할 때 굳이 따로 초기화 과정 거칠 필요 없다. 그냥 0으로 해도 됨*

### J1462
char 보다는 string 단위로 문제 해결하는게 좀 더 빠르다.

### J1082 (LIS + 역추적)
LIS + 역추적하기<br>
lis 배열에서 어느 idx 에 저장되었는지 기록해서 뒤에서부터 역추적하기<br>
역추적할 때 '누가 나를 바꿨는가'에 집중하면 해결 가능 - 따로 알고리즘이 있는 경우도 있음<br>
내가 한 방법 : 왜 안됐는지 

### J1180 (백트래킹)
백트래킹, dfs <br>
for loop로 돌리면 오히려 오버헤드 큼 <br>
그냥 나열하는 방식이 좋다 <br>

### J1225 (기하 - 원)
런타임 에러 주의하기
- 처음 접근 방법 <br>
사람 좌표 - 각 레이더 중심의 좌표 계산해서 lader1Dist 배열과 lader2Dist 배열에 나누어 저장함 <br>
-> 모든 케이스 커버 불가능 (ex. 한 레이더로만 사람 검사하는 경우)<br>
N 최대 : 5000 -> nlogn(quick sort) 2번 + N * (logN(binary search) + N) => 2ms 로 통과됨<br>
================= 굳이 퀵소트 안해도 됨 ===================<br>
double tempR = k/(divideCntx3.141)<br>
divideCnt 는 1000으로 선언, 1부터 1000까지 loop돌면서 lader1의 반지름(tempRxi), lader2의 반지름(tempRx(1000-i) 를 정하고, 어떤 점이 lader1에도 포함이 안되고, lader2에도 포함이 안되면? 감시 못하는 것!

### J2058 (BFS)
- 처음 접근 방법<br>
queue 두개 선언하여 동시에 bfs 진행하는 방법 -> 구현 어려움<br>
queue 하나로도 모두 해결 가능하다 -> queue의 크기 커봤자 25x25x25x25(고돌이 좌표 경우 x 고소미 좌표 경우) 이므로 충분히 선언 가능하다

### J1491 (DP)
아이디어 혼자 생각 못함 <br>
흔한 dp 접근법! 현재의 것 선택한다고 가정할 때의 최적의 값을 기록하는 아이디어!<br>
다른 접근법 : 현재 위치 까지의 거리가 최대거리를 초과하는 순간에 값 비교해서 업데이트 하기(?)

### J1328 (Stack)
dp로 풀려고 했었음 -> 시간 초과(왜 그런지 모르겠음)

### J2112 (DP)
규칙성 찾기 어려움<br>
- 내가 생각한 방법 : 2씩 끊어져서 타일 깔 때 (dpArr[i-2] * 3) <br>
모든 선에서 엇갈리게 넣을 때 (i번째라면 2^(i/2 -1)) <br>
부분 부분만 엇갈릴 때 : 이전에 엇갈린 경우의 수 * 3 * 3 <br>
=> 이렇게 하면 경우의 수 너무 많이 나옴 <br>

- 정답<br>
dp[31], sum[31] <br>
dp[i] = dp[i-2] + sum[i-2]x2 <br>
sum[i] = sum[i-2] + dp[i] <br>
맨 오른쪽 ㅣ 이렇게, ㅡ 이렇게 세우는 경우 나눠서 생각

### J1822 (DP)
너무 복잡하게 풀었음, dpArr에 쓸데없는 정보 너무 많다 <br>
일차원 배열로도 충분히 풀 수 있음 - 새로 태어난 애들만 저장해도 됨<br>
강사님 코드 : 새로 태어난 애들만 저장/ 죽는 애들은 처리 X -> 나중에 최종 결과 더할 때 (현재 날짜 -d) 일 부터 새로 태어난 애들 수 더하면 됨

### J1318 (HEAP)
처음 생각 : dp 이용하려고 함 <br>
1500번 수가 억단위라서 억 단위의 배열 필요 => heap을 이용해야 한다 (1500x3 크기)

### J1820, J1825 (DP)
아이디어 어려워서 블로그 참고함 <br>
path 출력 방법 더 간단한게 없을까?

### S1242
비트 패턴보다 비율을 활용해서 하는게 훨씬 빠르다 -> 나중에 최대공약수 이용해서 두께 1 짜리 데이터로 만들기

### 실전 day1_코끼리 (DP)
내가 만든 테이블 : 작커 경우, 커작 경우 따로 저장 -> 어차피 대칭이라 하나만 저장해도 될듯 <br>

- 점화식 좀 더 간단하게 만들 수 있음_테이블 채우다 보면 식 유도 가능하다<br>
dp[i][1] = dp[i-1][i-2] <br>
j가 2부터 i까지 <br>
dp[i][j] = (dp[i][j-1] + dp[i-1][i-j])

### 실전 day1_개미탈출
아이디어 어려움<br>

- 풀이 <br>
오른쪽으로 가는 애들만 따지면 된다 -> 오른쪽 선과 충돌하면 다른 선이 오른쪽 선의 위치 받아서 그대로 진행됨 <br>
이중 맵 이용하기! <br>

데이터를 빠르게 비교해야 한다! => 넣을 때 O(N), 뺄 때 O(logN) 인 map 사용해야 함 <br>
오른쪽으로 이동하는 애만 x기준으로 정렬 -> k번째로 잡고 진행 <br>
충돌할 때마다 인덱스 바꿔주기<br>
map<x, map <y, ant>> 이런식으로 데이터 다루기 -> cmp 함수 따로 정의<br>
정렬된 오른쪽 방향 선을 가지고! k번째 개미를 curAnt로 지정하고 검사 시작한다<br>
시간이 (M-k번째 선의 x위치) 가 될 때까지, 시간 t일 때 충돌하는 개미 구하고 그 개미와 인덱스 정보 바꾸기<br>
시간 다 되었을 때 curAnt 의 인덱스 출력한다


### 실전 day2_타일 채우기


### 실전 day3_부동산 문제
- 강사님 코드<br>
for (x1=1 ~ C), for (x2=1~C), for (y=1~R) 삼중루프 사용<br>
-> 이렇게 하면 모든 경우의 수 체크 불가능하지 않나...?

### 실전 day3_ 부대 만들기
인접 리스트를 이용해야 한다 (vector, list library 이용)
위상정렬 알고리즘


