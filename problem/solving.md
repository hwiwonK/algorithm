## TIP
BFS 할 때, queue에 넣을 때 visit 체크하는 것이 효율적이다(queue에 같은 것 또 들어가지 않게 하기 위해)<br>
정렬할 때 map 자료구조 쓰면 -> 넣거나 뺄 때 nlogn : 효율적임<br>
구조체는 한번에 초기화 가능!


## 문제풀이
### S1249
bfs로 풀어보기
(다익스트라, 다익스트라 + 우선순위큐, dfs)

### J2613 (BFS)
BFS 이용해서 풀이하기<br>
익은 토마토를 queue에 넣어놓고, 상-하-좌-우 체크하며 안 익은 것 queue에 넣고 level 체크
queue의 마지막 원소의 level 반환

0인 토마토 찾기 -> 1까지 최단거리 찾기 (시간 초과)

### J1113
새로운 minCorner 선언 안하고, 기존 input 배열 이용해도 됨

### J1906 (Disjoint Set)
공통 조상을 구하느 방법 <br>
visit 배열 이용하는 방법 -> 이 문제에서는 count 를 저장하면 됨 (촌수 계산 위해) <br>
level 이용하는 방법 -> 메모리 사용 안해도 됨
***부모 정보 저장할 때 굳이 따로 초기화 과정 거칠 필요 없다. 그냥 0으로 해도 됨*

### J1462
char 보다는 string 단위로 문제 해결하는게 좀 더 빠르다.

### J1082 (LIS + 역추적)
LIS + 역추적하기<br>
lis 배열에서 어느 idx 에 저장되었는지 기록해서 뒤에서부터 역추적하기<br>
역추적할 때 '누가 나를 바꿨는가'에 집중하면 해결 가능 - 따로 알고리즘이 있는 경우도 있음<br>
내가 한 방법 : 왜 안됐는지 

### J1180 (백트래킹)
백트래킹, dfs <br>
for loop로 돌리면 오히려 오버헤드 큼 <br>
그냥 나열하는 방식이 좋다 <br>

### J1225 (기하 - 원)
런타임 에러 주의하기
- 처음 접근 방법
사람 좌표 - 각 레이더 중심의 좌표 계산해서 lader1Dist 배열과 lader2Dist 배열에 나누어 저장함 <br>
-> 모든 케이스 커버 불가능 (ex. 한 레이더로만 사람 검사하는 경우)<br>
N 최대 : 5000 -> nlogn(quick sort) 2번 + N * (logN(binary search) + N) => 2ms 로 통과됨<br>
====================================== 굳이 퀵소트 안해도 됨 =======================================================<br>
double tempR = k/(divideCntx3.141)<br>
divideCnt 는 1000으로 선언, 1부터 1000까지 loop돌면서 lader1의 반지름(tempRxi), lader2의 반지름(tempRx(1000-i) 를 정하고, 어떤 점이 lader1에도 포함이 안되고, lader2에도 포함이 안되면? 감시 못하는 것!

### J2058 (BFS)
- 처음 접근 방법
queue 두개 선언하여 동시에 bfs 진행하는 방법 -> 구현 어려움<br>
queue 하나로도 모두 해결 가능하다 -> queue의 크기 커봤자 25x25x25x25(고돌이 좌표 경우 x 고소미 좌표 경우) 이므로 충분히 선언 가능하다

### J1491 (DP)
아이디어 혼자 생각 못함 <br>
흔한 dp 접근법! 현재의 것 선택한다고 가정할 때의 최적의 값을 기록하는 아이디어!<br>
다른 접근법 : 현재 위치 까지의 거리가 최대거리를 초과하는 순간에 값 비교해서 업데이트 하기(?)
