## TIP
BFS 할 때, queue에 넣을 때 visit 체크하는 것이 효율적이다(queue에 같은 것 또 들어가지 않게 하기 위해)<br>
정렬할 때 map 자료구조 쓰면 -> 넣거나 뺄 때 nlogn : 효율적임


## 문제풀이
### S1249
bfs로 풀어보기
(다익스트라, 다익스트라 + 우선순위큐, dfs)

### J2613
BFS 이용해서 풀이하기<br>
익은 토마토를 queue에 넣어놓고, 상-하-좌-우 체크하며 안 익은 것 queue에 넣고 level 체크
queue의 마지막 원소의 level 반환

0인 토마토 찾기 -> 1까지 최단거리 찾기 (시간 초과)

### J1113
새로운 minCorner 선언 안하고, 기존 input 배열 이용해도 됨

### J1906
공통 조상을 구하느 방법 <br>
visit 배열 이용하는 방법 -> 이 문제에서는 count 를 저장하면 됨 (촌수 계산 위해) <br>
level 이용하는 방법 -> 메모리 사용 안해도 됨
***부모 정보 저장할 때 굳이 따로 초기화 과정 거칠 필요 없다. 그냥 0으로 해도 됨*

### J1462
char 보다는 string 단위로 문제 해결하는게 좀 더 빠르다.

### J1082
LIS + 역추적하기<br>
lis 배열에서 어느 idx 에 저장되었는지 기록해서 뒤에서부터 역추적하기<br>
역추적할 때 '누가 나를 바꿨는가'에 집중하면 해결 가능 - 따로 알고리즘이 있는 경우도 있음<br>

내가 한 방법 : 왜 안됐는지 
